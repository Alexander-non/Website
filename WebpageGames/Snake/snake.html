<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Snakey</title>
    </head>
    <body>
        <style>
            @font-face {
                /*https://www.dafont.com/crang.font?text=Game+Over%21&back=bitmap*/
                font-family: "Crang";
                src: url("Assets/Crang.ttf");
            }
            :root {
                --canvasHeight: 750px;
                --canvasWidth: 750px;
            }
            body {
                background-image: url("Assets/pxArt.png");
                background-repeat: no-repeat;
                background-size: cover;
                background-attachment: fixed;
            }
            body::-webkit-scrollbar {display: none;}
            .canvas-holder {
                position: absolute;
                width: var(--canvasWidth);
                height: var(--canvasHeight);
                left: calc(50% - calc(var(--canvasWidth) / 2));
                top: calc(50% - calc(var(--canvasHeight) / 2));
                perspective: 500px;
                background-color: green;
            }

            canvas {
                position: absolute;
                width: 100%;
                height: 100%;
                transform-origin: center;
                perspective: 500px;
                animation: 3s linear 1s infinite running none;
            }
            #gameOverScreen {
                z-index: 100;
                position: absolute;
                top: 0vh;
                left: 0vw;
                width: 100vw;
                height: 100vh;
                display: flex;
                flex-direction: column;
                align-items: center;
                background-color: rgb(0, 0, 0, 0.5);
                transition-duration: 1s;
                opacity: 0;
            }
            #gameOverScreen > h1 {
                position: relative;
                margin-top: 5vh;
                color: white;
                text-align: center;
                font-family: Crang;
                font-size: 5em;
            }
            #img-preloader {
                display: none;
            }
        </style>
        <div class="canvas-holder"><canvas id="gameCanvas"></canvas></div>
        <div id="gameOverScreen">
            <h1>Game Over!</h1>
            <canvas id="deathCanvas"></canvas>
        </div>
        <div id="img-preloader">
            <img id="snakeHead_W" src="Assets/Snake/head_w.png">
            <img id="snakeHead_D" src="Assets/Snake/head_d.png">
            <img id="snakeHead_A" src="Assets/Snake/head_a.png">
            <img id="snakeHead_S" src="Assets/Snake/head_s.png">
            <img id="body_W" src="Assets/Snake/body_w.png">
            <img id="body_D" src="Assets/Snake/body_d.png">
            <img id="body_A" src="Assets/Snake/body_a.png">
            <img id="body_S" src="Assets/Snake/body_s.png">
            <img id="fruit_skin_1" src="Assets/Fruits/apple.png">
        </div>
        <script>
            let canvas = document.querySelector("#gameCanvas");
            canvas.width = 750;
            canvas.height = 750;
            let ctx = canvas.getContext("2d");            
            //Extra functions
            function rand(min, max){return Math.floor(Math.random() * (max - min) + min);};

            const boardSize = 24;
            let w = canvas.width/boardSize;
            let h = canvas.height/boardSize;
            
            let start = true;
            let fps, fpsInterval, now, then, elapsed;
            function startGame(fps) {
                fpsInterval = 1000 / fps;
                then = Date.now();
                update();
            }
            
            let bodyPart = ['head', 'body'];
            const snakePart = function(x, y, w, h, type, direction) {
                this.x = x;
                this.y = y;
                this.h = h;
                this.w = w;
                this.type = type;
                this.direction = direction;

                let snakeSkin = new Image();
                this.draw = function() {
                    /*
                        var current = new Image();
                        function loadImage(){
                        var img = new Image(); // if you really want to optimize your code for memory impact, you could declare it only once out of the function...
                        img.onload = function(){
                            current = this; // update the image to be rendered with the new & loaded one
                            setTimeout(loadImage, 2000); // start loading a new one in 2 sec (will be rendered even later)
                            }
                        img.onerror = loadImage;
                        img.src = 'https://upload.wikimedia.org/wikipedia/commons' + urls[++url_index % urls.length]+'?'+Math.random();
                        }
                    */
                    if (this.type == bodyPart[0]) {
                        //FIX FOR FLASHING https://stackoverflow.com/questions/46197034/canvas-flickers-when-trying-to-draw-image-with-updated-src
                        switch (this.direction) {
                            case "w":
                                snakeSkin.src = `./Assets/Snake/head_${this.direction}.png`;
                                break;
                            case "s":
                                snakeSkin.src = `./Assets/Snake/head_${this.direction}.png`;
                                break;
                            case "d":
                                snakeSkin.src = `./Assets/Snake/head_${this.direction}.png`;
                                break;
                            case "a":
                                snakeSkin.src = `./Assets/Snake/head_${this.direction}.png`;
                                break;
                        }
                    }
                    else if (this.type == bodyPart[1]) {
                        switch (this.direction) {
                            case "w":
                                snakeSkin.src = `./Assets/Snake/body_${this.direction}.png`;
                                break;
                            case "s":
                                snakeSkin.src = `./Assets/Snake/body_${this.direction}.png`;
                                break;
                            case "d":
                                snakeSkin.src = `./Assets/Snake/body_${this.direction}.png`;
                                break;
                            case "a":
                                snakeSkin.src = `./Assets/Snake/body_${this.direction}.png`;
                                break;
                        }
                    }
                    ctx.drawImage(snakeSkin, this.x*(this.w), this.y*(this.h), this.w, this.h);
                };
                this.collision = function() {
                    for (let i = 0; i < snakeArray.length; i++) {
                        if (snakeArray[i].type != 'head') {
                            if (snakeArray[0].x == snakeArray[i].x && snakeArray[0].y == snakeArray[i].y) {Gameover()}
                        };
                    }
                };
            };
            const Fruit = function(x, y) {
                this.x = x
                this.y = y
                this.die = function() {
                    snakeArray.push(new snakePart(0,0, canvas.width/boardSize, canvas.height/boardSize, snakeType));
                    fruit = new Fruit(rand(0, boardSize-1), rand(0, boardSize-1));
                };
                this.draw = function() {
                    let appleSkin = new Image();
                    appleSkin.src = `./Assets/Fruits/apple.png`;
                    ctx.drawImage(appleSkin, this.x*(w), this.y*(h), w, h);
                }
            };
            let fruit = new Fruit(Math.floor(boardSize/2),Math.floor(boardSize/2));

            function Gameover() {
                cancelAnimationFrame(gameRefresh);
                const deathScreen = document.querySelector("#gameOverScreen");
                deathScreen.style.opacity = 1;
            };

            //PROTOTYPE
            const maxInclination = 7.5;
            function Inclination(maxDegree) {
                let X_val = -(Math.floor(boardSize/2)-snakeArray[0].x);
                if (X_val > maxDegree) {X_val = maxDegree}
                else if (X_val < -maxDegree) {X_val = -maxDegree}
                let Y_val = Math.floor(boardSize/2)-snakeArray[0].y;
                if (Y_val > maxDegree) {Y_val = maxDegree}
                else if (Y_val < -maxDegree) {Y_val = -maxDegree}
                canvas.style.transform = `rotateX(${Y_val}deg) rotateY(${X_val}deg)`;
            };

            //Generating Snake
            let snakeStartSize = 4
            let snakeArray = [];
            let pastSnakeArray = [];
            let snakeTyped;
            for (let i = 0; i < snakeStartSize; i++) {
                if (i == 0) {snakeType = 'head'} else {snakeType = 'body'};
                let tempSnake = new snakePart(Math.abs(i - snakeStartSize), Math.floor(boardSize/2), canvas.width/boardSize, canvas.height/boardSize, snakeType, "d");
                snakeArray.push(tempSnake);
            };
            //Controls
            let state = 'd';
            let keybuffer = [];
            window.addEventListener("keydown", function(event) {
                pressable = ["w", "a", "s", "d"];
                if (pressable.indexOf(event.key) >= 0) {
                    start = false;
                    keybuffer.push(event.key)};
            });
            //Grass tilemap generation
            let grassMap = [];
            for (let x = 0; x < boardSize; x++) {
                let tempArray = [];
                for (let y = 0; y < boardSize; y++) {tempArray.push(rand(0, 4))};
                grassMap.push(tempArray);
            };

            let gameRefresh;
            function update() {
                ctx.clearRect(0,0,canvas.width,canvas.height);
                gameRefresh = requestAnimationFrame(update);
                now = Date.now();
                //Generating background map
                for (let x = 0; x < grassMap.length; x++) {
                    for (let y = 0; y < grassMap.length; y++) {
                        let grassTile = new Image();
                        grassTile.src = `./Assets/grass${grassMap[x][y]}.png`;
                        ctx.drawImage(grassTile, x*(w), y*(h), w, h);
                    };
                };
                elapsed = now - then;
                while (keybuffer.length > 5) {keybuffer.pop()};
                if (elapsed > fpsInterval) {
                    then = now - (elapsed % fpsInterval);
                    pastSnakeArray = JSON.parse(JSON.stringify(snakeArray));
                    //Keybuffer
                    for (let u = 0; u < keybuffer.length; u++) {
                        if ((state == "w" || state == undefined) && keybuffer[0] != "s") {state = keybuffer[0];}
                        if ((state == "s" || state == undefined) && keybuffer[0] != "w") {state = keybuffer[0];}
                        if ((state == "a" || state == undefined) && keybuffer[0] != "d") {state = keybuffer[0];}
                        if ((state == "d" || state == undefined) && keybuffer[0] != "a") {state = keybuffer[0];}
                        for (let i = 0; i < snakeArray.length; i++) {if (snakeArray[i].type == "head") {snakeArray[i].direction = state}};
                    };
                    keybuffer.shift();
                    //Movement
                    let speed = 1;
                    for (let i = 0; i < snakeArray.length; i++) {
                        if (start == false) {
                            if (snakeArray[i].type == 'head') {
                                switch (snakeArray[i].direction) {
                                    case pressable[0]:
                                        if (snakeArray[i].y > 0) {snakeArray[i].y -= speed} else {Gameover()};
                                        break;
                                    case pressable[2]:
                                        if(snakeArray[i].y < boardSize-1) {snakeArray[i].y += speed} else {Gameover()};
                                        break;
                                    case pressable[3]:
                                        if (snakeArray[i].x < boardSize-1) {snakeArray[i].x += speed} else {Gameover()};
                                        break;
                                    case pressable[1]:
                                        if (snakeArray[i].x > 0) {snakeArray[i].x -= speed} else {Gameover()};
                                        break;
                                    default:
                                        break;
                                };
                            };
                            if (i > 0) {
                                snakeArray[i].x = pastSnakeArray[i-1].x;
                                snakeArray[i].y = pastSnakeArray[i-1].y;
                                snakeArray[i].direction = pastSnakeArray[i-1].direction;
                            };
                        };
                    };
                    
                };
                //Drawing assets
                let snakeCurrentSize = snakeArray.length;
                for (let i = 0; i < snakeCurrentSize; i++) {
                    snakeArray[i].draw();
                    snakeArray[i].collision();
                    if(Math.round(snakeArray[i].x) == fruit.x && Math.round(snakeArray[i].y) == fruit.y) {fruit.die()};
                };
                fruit.draw();
                //Applying Miscs
                //Inclination(maxInclination);
            };
            startGame(10)
        </script>
    </body>
</html>